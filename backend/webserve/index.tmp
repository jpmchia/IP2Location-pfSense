package webserve

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/jpmchia/ip2location-pfsense/backend/util"
	"github.com/labstack/echo/v4"
	echomiddleware "github.com/labstack/echo/v4/middleware"
)

const DefaultIndexFilename = "index.html"

// IndexConfig defines the config for the middleware which determines the path to load
// the SPA index file
type PrefixConfig struct {
	// Skipper defines a function to skip middleware
	echomiddleware.Skipper

	// ExcludePrefix defines a list of paths to exclude from the prefix middleware
	ExcludePrefix []string

	// Prefix to add
	Prefix string

	// The name of the file used as the index, defaults to index.html
	IndexFilename string
}

// PrefixWithConfig configure the prefix middleware
func PrefixWithConfig(config PrefixConfig) echo.MiddlewareFunc {

	if config.Skipper == nil {
		config.Skipper = echomiddleware.DefaultSkipper
	}
	if config.Prefix == "" {
		config.Prefix = "/static"
	}
	if config.ExcludePrefix == nil {
		config.ExcludePrefix = []string{"/static"}
	}
	if config.IndexFilename == "" {
		config.IndexFilename = DefaultIndexFilename
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {

			if config.Skipper(c) {
				return next(c)
			}

			// Parse the original URL
			//url.Parse(c.Request().URL.Path)
			u, err := url.ParseRequestURI(c.Request().RequestURI)

			if err != nil {
				util.HandleError(err, "[webserve] Unable to determine the URL to rewrite in %v", u)
			}
			u.Path = strings.TrimSuffix(u.Path, "/")

			fmt.Printf("ORIGINAL URL: %v\n", u)
			fmt.Printf("u.Path: %v\n", u.Path)
			fmt.Printf("h.Host: %v\n", c.Request().Host)

			// Check if the path of the URL starts with one of the specified exclude prefixes
			shouldExclude := false
			for _, prefix := range config.ExcludePrefix {
				if strings.HasPrefix(u.Path, prefix) {
					fmt.Printf("Found prefix: %v\n", prefix)
					shouldExclude = true
					break
				}
			}
			fmt.Printf("shouldExclude: %v\n", shouldExclude)

			// If the path should not be excluded and it doesn't already start with the insertPrefix,
			// then insert the insertPrefix to the path of the URL
			if !shouldExclude && !strings.HasPrefix(u.Path, config.Prefix) {
				u.Path = config.Prefix + u.Path
				fmt.Printf("Updated u.Path: %v\n", u.Path)
			}

			// Print the modified URL
			fmt.Printf("FINAL URL: %s\n", u.String())

			// var pathPrefix string
			// p := c.Request().URL.Path
			// u := c.Request().URL
			// h := c.Request().Host
			// pathPrefix = extractPathPrefix(h, config.ExcludePrefix)

			// fmt.Println("pathPrefix: ", pathPrefix)
			// fmt.Println("p: ", p)
			// fmt.Println("u: ", u)
			// fmt.Println("h: ", h)

			// if strings.HasSuffix(p, "/") {
			// 	u.Path = path.Join("/", config.Prefix, pathPrefix, config.IndexFilename)
			// } else {
			// 	u.Path = path.Join("/", pathPrefix, p)
			// }

			return next(c)
		}
	}
}

func ServeStaticWihtoutPath(e *echo.Echo, definedPaths []string) *echo.Echo {
	e.Pre(echomiddleware.AddTrailingSlash())
	e.Use(PrefixWithConfig(PrefixConfig{
		Prefix:        "/static",
		ExcludePrefix: definedPaths,
		IndexFilename: DefaultIndexFilename,
	}))
	return e
}

// func extractPathPrefix(host string, excludePrefixes []string) string {

// 	for _, prefix := range excludePrefixes {
// 		if strings.HasPrefix(host, prefix) {
// 			return ""
// 		}
// 	}

// 	domainName := "localhost"

// 	if !strings.HasSuffix(host, domainName) {
// 		return ""
// 	}

// 	// Remove the domain name

// 	subdomain := strings.TrimSuffix(host, domainName)

// 	if !strings.HasSuffix(subdomain, ".") {
// 		return ""
// 	}

// 	return strings.TrimSuffix(subdomain, ".")
// }
